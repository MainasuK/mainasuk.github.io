<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Below the horizon]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://mainasuk.com/"/>
  <updated>2016-01-21T08:05:57.000Z</updated>
  <id>http://mainasuk.com/</id>
  
  <author>
    <name><![CDATA[MainasuK]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[OpenGL 纹理漫谈]]></title>
    <link href="http://mainasuk.com/2016/01/21/OpenGLTexture/"/>
    <id>http://mainasuk.com/2016/01/21/OpenGLTexture/</id>
    <published>2016-01-21T07:58:00.000Z</published>
    <updated>2016-01-21T08:05:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="2D__u7EB9_u7406_u6620_u5C04"><a href="#2D__u7EB9_u7406_u6620_u5C04" class="headerlink" title="2D 纹理映射"></a>2D 纹理映射</h1><p>纹理映射一般是在图形的坐标值已经计算完成时附加在顶点信息上的，而非对纹理进行透视、变换再显示。下面逐步介绍如何在 OpenGL 中开启纹理映射，它的顺序有先后但并不唯一，若是想颠倒一下顺序也不妨试试看会有什么效果🙃️</p>
<h2 id="u8BFB_u53D6_u7EB9_u7406_u56FE"><a href="#u8BFB_u53D6_u7EB9_u7406_u56FE" class="headerlink" title="读取纹理图"></a>读取纹理图</h2><p>纹理图的格式一般为原始 RGB 格式，一个字节（8 bits）代表一种颜色通道，一个像素的颜色用三个字节表示，例如白色记为 <code>#FFFFFF</code>，是不是很熟悉，这种表示方式即 RGB888，由或者称其为 24 位真彩色。除此之外还有一些其他常用的格式：RGBA8888，RGB565，RGBA5551……</p>
<p>纹理图通常是正方形，若图形 API 没有严格限制，也可以为矩形。大多数图形卡及图形 API 为了效率的原因，限制图像分辨率为 2 的幂，例如 256*256，具体要求请参考文档。</p>
<p><img src="http://ww4.sinaimg.cn/large/72d7aee5jw1f068lt6aaaj218v0qaqar.jpg" alt="Photoshop 导出原始 RGB 图像"></p>
<p>这里我们使用 Photoshop 将图片裁剪成 512*512 分辨率，然后将其导出为原始 RGB 格式的图像，只要在存储时选择 Photoshop raw 格式即可（别和单反的那种 RAW 搞混了哦）。导出后的文件记录着自左上角向右下角逐行扫描的 RGB 信息。</p>
<p><img src="http://ww2.sinaimg.cn/large/72d7aee5jw1f068pzyeqxj20te0itwm5.jpg" alt="查看 RAW 文件"></p>
<p>使用十六进制文本查看器查看导出的文件，可以看到共 512*512*3 = 786432 字节，查看前三个字节组成的颜色 <code>#444135</code>，大致是深褐色。</p>
<a id="more"></a>
<p>若在原始 RGB 文件头加入图像的高度和宽度信息，则类似于 <a href="https://en.wikipedia.org/wiki/Netpbm_format" target="_blank" rel="external">ppm</a> 格式。除此之外，纹理图还有压缩格式，比较著名的是 <a href="https://en.wikipedia.org/wiki/S3_Texture_Compression" target="_blank" rel="external">S3TC</a> 格式，它被大多数图形卡支持，它提高了内存读取效率，游戏引擎大多会用到这样的技术。</p>
<p>读取原始 RGB 格式的图片是很简单的，一个简单的函数就可以完成这项工作。读取成功后，一个 GLubyte 类型的指针指向存储纹理图的地址，它的大小为 <code>width*height*3</code> 个 <code>unsigned char</code>，可以理解为一个三维数组<code>texImage[width][height][3]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">raw_texture_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    GLubyte *data;</span><br><span class="line">    FILE *infile;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  Open texture data</span></span><br><span class="line">    infile = fopen(filename, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == infile) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s open failed.\n"</span>, filename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  Allocate buffer</span></span><br><span class="line">    data = (GLubyte*)<span class="built_in">malloc</span>(width * height * <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    fread(data, (width*height*<span class="number">3</span>), <span class="number">1</span>, infile);</span><br><span class="line">    fclose(infile);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了从文件读取纹理图之外，还有其他方式获得纹理图，例如使用函数生成，或者直接将颜色缓冲区的内容读取出用作纹理。</p>
<p>使用图像纹理图是很普遍的做法，OpenGL 也支持一些其他类型的纹理数据，比如<a href="https://www.opengl.org/discussion_boards/showthread.php/151701-GL_LUMINANCE-vs-GL_INTENSITY" target="_blank" rel="external">强度、明度</a>等，在制作地形效果时可以利用到。</p>
<h2 id="u751F_u6210_u7EB9_u7406"><a href="#u751F_u6210_u7EB9_u7406" class="headerlink" title="生成纹理"></a>生成纹理</h2><p>将原始 RGB 信息保存到内存中只是第一步，接下来需要使用 API 来生成纹理。首先我们询问 API 获得纹理名称，使用得到的纹理名称与某种纹理类型进行绑定，之后调整纹理参数，最后将将纹理数据和纹理的元信息告诉 API，此时纹理便生成完毕，生成的纹理通过纹理名称来访问。</p>
<p>纹理名称的获取与绑定一般代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">raw_texture_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    GLuint texture;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//  Allocate a texture name</span></span><br><span class="line">    glGenTextures(<span class="number">1</span>, &amp;texture);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  Select our current texture</span></span><br><span class="line">    glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u8C03_u6574_u7EB9_u7406_u53C2_u6570"><a href="#u8C03_u6574_u7EB9_u7406_u53C2_u6570" class="headerlink" title="调整纹理参数"></a>调整纹理参数</h2><p>OpenGL 提供了一系列的 GLenum 类型的参数，查看源码可以发现它是一些宏定义。这里我们通过调用函数 <code>glTexParameterf(GLenum target, GLenum pname, GLfloat param)</code> 进行纹理参数设置。纹理参数设置函数有多个系列，目前除了 <code>glTextureParameter</code> 系列函数只被 OpenGL 4.5 支持外，其余函数系列都是向后兼容的，具体信息请参考<a href="https://www.opengl.org/sdk/docs/man4/html/glTexParameter.xhtml" target="_blank" rel="external">文档</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">raw_texture_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);</span><br><span class="line">    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的第一个参数为 target，我们根据纹理类型的不同选择调用不同的宏。纹理类型是指颜色信息存在的维度。一般来说我们使用 2D 纹理，某些场合下可以用到 1D 或 3D 纹理，</p>
<p>后面两个参数需要搭配在一起使用，这里我们主要关心两种搭配，反卷与过滤。如上所说，纹理映射的方式并不是简单的透视变换，而是将纹理信息附加在计算好的多边形的顶点信息上。纹理图的坐标范围为 [0, 1]，反卷指当纹理坐标超出这个范围如何处理；过滤则涉及到纹理图的映射方法。</p>
<h3 id="u53CD_u5377"><a href="#u53CD_u5377" class="headerlink" title="反卷"></a>反卷</h3><p><img src="http://ww4.sinaimg.cn/large/72d7aee5jw1f071hi673yj20sg0lcafn.jpg" alt="UV 坐标系"></p>
<p>出现反卷纹理的情况是由于纹理坐标值不一定在 [0…1] 之间，与纹理数据所不同，纹理空间的坐标是典型的笛卡尔坐标系，原点在左下角。这与 Direct X 所不同（原点在左上角）。纹理坐标值以 (u, v) 表示，有人称其为 UV 坐标系。OpenGL 将纹理的第一二三及齐次坐标定义为 GL_S、GL_T、GL_R、GL_Q。调用 <code>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP)</code> 就完成单独指定 u 方向的反卷方式为 <code>GL_CLAMP</code>。</p>
<p><img src="http://ww3.sinaimg.cn/large/72d7aee5jw1f071lg3xjvj20sg0lc7aq.jpg" alt="Wrap 方式"></p>
<h3 id="u8FC7_u6EE4"><a href="#u8FC7_u6EE4" class="headerlink" title="过滤"></a>过滤</h3><p>在纹理映射的过程中，当纹理图的每个像素都恰好映射到屏幕上的每个像素时，纹理图是清晰的。当纹理图不能恰好映射的时候，就会出现插值的问题。先考虑纹理图映射到比自身分辨率大的屏幕上，这时纹理密度小于 1，每个纹元对应多个像素，若是使用简单的映射方法，将会出现块状纹理。OpenGL 提供了放大过滤器，用户可以选择过滤器的技术。同样，若纹理密度大于 1 也会出现多个纹元对应一个像素的问题，类似的技术和方法可以将其解决。</p>
<p>游戏引擎中经常要渲染大量纹理，为了避免因纹理密度导致的问题，提出了多纹理技术（<a href="https://en.wikipedia.org/wiki/Mipmap" target="_blank" rel="external">MIP</a>）。当进行纹理映射时，图形 API 选择合适分辨率的纹理，从而提升性能和质量。MIP 技术也可以有效解决倾斜表面的纹理渲染问题，一些常用的纹理滤波技术可以参考<a href="https://zh.wikipedia.org/wiki/%E7%BA%B9%E7%90%86%E6%BB%A4%E6%B3%A2" target="_blank" rel="external">百科</a>，游戏玩家对于这些名词是熟悉的。</p>
<p>下面以最临近插值和线性插值做对比，可以观察出细微的不同。</p>
<p><img src="http://ww2.sinaimg.cn/large/72d7aee5jw1f071mhcclsj20sg0lcwj8.jpg" alt="GL_NEAREST"></p>
<p><img src="http://ww2.sinaimg.cn/large/72d7aee5jw1f071oplnt2j20sg0lcq6k.jpg" alt="GL_LINAR"></p>
<h2 id="u5B9A_u4E49_u7EB9_u7406"><a href="#u5B9A_u4E49_u7EB9_u7406" class="headerlink" title="定义纹理"></a>定义纹理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GLuint <span class="title">raw_texture_load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGB8, width, height, <span class="number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">    <span class="keyword">return</span> texture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户使用 <code>gllTexImage2D(GLenum target, GLint level, GLint internal format, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)</code> 函数传递纹理数据指针 <code>pixels</code> 和纹理元数据，与之前用户调用 <code>glBindTexture</code> 声明的纹理进行关联。完成这一步之后，接下来就可以通过纹理名称来访问这个纹理。</p>
<p>函数的参数含义如下：</p>
<ul>
<li>target: 纹理类型</li>
<li>level: MIP 层次</li>
<li>internal format: 有人也称其为 Dest，指这里定义纹理的格式</li>
<li>width / height: 纹理图的宽度和高度，OpenGL 的实现可以保证支持到 1024 像素宽和高。1D 纹理图的高度为 1，不需要设置。</li>
<li>border: 是否包含边界，1 为是，0 为否。文档指出此值必须为 0 （该参数已废弃，但仍需传值）。</li>
<li>format: 有人称 Source，指纹理数据的格式。</li>
<li>type: 纹理数据的数据类型，例如 <code>GL_UNSIGNED_BYTE</code>。</li>
<li>pixels: 纹理数据指针。</li>
</ul>
<p>简单来讲，这个函数将用户的纹理数据定义为纹理，供 OpenGL 使用。</p>
<h2 id="u5BF9_u591A_u8FB9_u5F62_u8FDB_u884C_u7EB9_u7406_u6620_u5C04"><a href="#u5BF9_u591A_u8FB9_u5F62_u8FDB_u884C_u7EB9_u7406_u6620_u5C04" class="headerlink" title="对多边形进行纹理映射"></a>对多边形进行纹理映射</h2><p>纹理坐标可以直接设置，也可以通过参数生成，这里先介绍第一种方法。</p>
<p>在绘制多边形之前，使用 <code>glEnable</code> 开启纹理映射，接下来使用 <code>glTexEnvi</code> 设置纹理环境（值得注意的是该调用环境会影响到该语句之后的所有纹理映射），并传入纹理名称到 <code>glBindTexture</code> 完成纹理映射准备。</p>
<p>代码如下，在下面进行介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_TEXTURE_2D);</span><br><span class="line">glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texName[<span class="number">0</span>]);</span><br><span class="line">glBegin(GL_QUADS);</span><br><span class="line">glNormal3f(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">glTexCoord2f( <span class="number">0.0</span>,  <span class="number">0.0</span>); glVertex3fv(plane[<span class="number">0</span>]);</span><br><span class="line">glTexCoord2f( <span class="number">0.0</span>,  <span class="number">1.0</span>); glVertex3fv(plane[<span class="number">1</span>]);</span><br><span class="line">glTexCoord2f( <span class="number">1.0</span>,  <span class="number">1.0</span>); glVertex3fv(plane[<span class="number">2</span>]);</span><br><span class="line">glTexCoord2f( <span class="number">1.0</span>,  <span class="number">0.0</span>); glVertex3fv(plane[<span class="number">3</span>]);</span><br><span class="line">glEnd();</span><br><span class="line">glFlush();</span><br><span class="line">glDisable(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure>
<h2 id="u8BBE_u7F6E_u7EB9_u7406_u73AF_u5883"><a href="#u8BBE_u7F6E_u7EB9_u7406_u73AF_u5883" class="headerlink" title="设置纹理环境"></a>设置纹理环境</h2><p>调用 <code>glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)</code> 设置纹理环境，其中 <code>GL_MODULATE</code> 是纹理环境的默认方法，其余方法有 <code>GL_BLEND</code>、<code>GL_DECAL</code>、<code>GL_REPLACE</code>。用户可以在这项模式中切换。这些参数的含义与纹理数据与物体表面颜色之间混合的方式有关，关于这些技术具体的实现和作用，请参考<a href="http://docs.gl/gl3/glTexEnv" target="_blank" rel="external">文档</a>。</p>
<h2 id="u8BBE_u7F6E_u7EB9_u7406_u5750_u6807"><a href="#u8BBE_u7F6E_u7EB9_u7406_u5750_u6807" class="headerlink" title="设置纹理坐标"></a>设置纹理坐标</h2><p>在绘制前设置法向量，它决定了纹理的方向。绘制顶点时调用 <code>glTexCoord2f(u, v)</code> 即可完成纹理坐标与多边形坐标的绑定，这里 <code>(u, v)</code> 可以超出 [0…1] 的限制，此时纹理的行为由纹理反卷方式决定。在渲染过程中，系统将根据顶点中纹理坐标的信息进行纹理映射。</p>
<p><img src="http://ww2.sinaimg.cn/large/72d7aee5jw1f071xv88qvj218n0kegs5.jpg" alt="多个纹理"></p>
<p>我们可以生成多个纹理，通过不同的纹理名称重复地对多边形进行映射，这与 MIP 类似但不同。</p>
<h1 id="1D__u7EB9_u7406_u6620_u5C04"><a href="#1D__u7EB9_u7406_u6620_u5C04" class="headerlink" title="1D 纹理映射"></a>1D 纹理映射</h1><p><img src="http://ww3.sinaimg.cn/large/72d7aee5jw1f075utlh0ij20x00ke0v0.jpg" alt="ChromaDepth"></p>
<p>接下来我们使用函数生成 1D 纹理，再使用生成纹理坐标的方法将其渲染到模型上，这里我们使用一种称为 <a href="https://en.wikipedia.org/wiki/ChromaDepth" target="_blank" rel="external">ChromaDepth</a> 的 3D 技术（在地形显示方面也有所应用)。这是一种比较古老的虚拟 3D 技术，只要有对应的眼镜就可以看到类似 3D 物体的效果。要找个类比的话，大概就是红蓝 3D 吧。近处物体渲染为红色，远处物体渲染为蓝色，通过眼镜观看，由于眼镜的衍射率不同，红色大于蓝色，人眼会认为衍射率大的红色比蓝色近，从而产生 3D 视觉效果。</p>
<p>我们只要定义 1D 的纹理，再通过 <code>glTexGeni</code> 函数将纹理坐标自动生成出来就可以了。</p>
<h2 id="u751F_u6210_u7EB9_u7406-1"><a href="#u751F_u6210_u7EB9_u7406-1" class="headerlink" title="生成纹理"></a>生成纹理</h2><p>使用 RGB 色彩空间创建从红到蓝的渐变并不方便，我们使用 <a href="https://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4" target="_blank" rel="external">HSV 色彩空间</a>，喜欢数码绘图的朋友一定会很熟悉 HSV 拾色器。设置饱和度（S）和亮度（V）都为 1，将色度（H）由 0 度（红色）变换到 240 度（蓝色）。将这一变化序列转化为 RGB 存储并生成 1D 纹理。这里不再介绍如何 RGB 与 HSV 的转换。创建纹理数据的一般代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeRamp</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">float</span> h, s, v, r, g, b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  0 to 240 ramp, total 256 steps</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        h = (<span class="keyword">float</span>)i * <span class="number">240.0</span> / <span class="number">255.0</span>;</span><br><span class="line">        s = <span class="number">1.0</span>;</span><br><span class="line">        v = <span class="number">1.0</span>;</span><br><span class="line">        convertHSV2RGB(h, s, v, &amp;r, &amp;g, &amp;b);</span><br><span class="line">        ramp[i][<span class="number">0</span>] = r;</span><br><span class="line">        ramp[i][<span class="number">1</span>] = g;</span><br><span class="line">        ramp[i][<span class="number">2</span>] = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u5B9A_u4E49_u7EB9_u7406-1"><a href="#u5B9A_u4E49_u7EB9_u7406-1" class="headerlink" title="定义纹理"></a>定义纹理</h2><p>这里我们的到了一个长度为 256 的 1D 纹理数据。与 2D 纹理定义类似，接下来开启 1D 纹理映射，调整纹理参数，定义一个 1D 纹理。在开启 1D 纹理映射之后，我们调用 <code>glEnable(GL_TEXTURE_GEN_S)</code> 开启纹理 S 方向上的坐标生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glEnable(GL_TEXTURE_1D);</span><br><span class="line">glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);</span><br><span class="line">glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_CLAMP);</span><br><span class="line">glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">glTexImage1D(GL_TEXTURE_1D, <span class="number">0</span>, GL_RGB8, <span class="number">256</span>, <span class="number">0</span>, GL_RGB, GL_FLOAT, ramp);</span><br></pre></td></tr></table></figure>
<h2 id="u751F_u6210_u7EB9_u7406-2"><a href="#u751F_u6210_u7EB9_u7406-2" class="headerlink" title="生成纹理"></a>生成纹理</h2><p>我们使用眼空间来生成纹理，函数调用的顺序不唯一，但要确保 <code>glTexGenfv</code> 在 <code>gluLookAt</code> 之前调用，代码如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D1 = <span class="number">5.0</span>;</span><br><span class="line">D2 = <span class="number">15.0</span>;</span><br><span class="line">texParms[<span class="number">0</span>] = texParms[<span class="number">1</span>] = <span class="number">0.0</span>;</span><br><span class="line">texParms[<span class="number">2</span>] = -<span class="number">1.0</span> / (D2-D1);</span><br><span class="line">texParms[<span class="number">3</span>] = -D1/(D2-D1);</span><br><span class="line"></span><br><span class="line">glEnable(GL_TEXTURE_1D);</span><br><span class="line">glTexGenfv(GL_S, GL_EYE_PLANE, texParms);</span><br><span class="line">glBindTexture(GL_TEXTURE_1D, texName);</span><br><span class="line">glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">//          eye point   center of view      up</span></span><br><span class="line">gluLookAt(camX, camY, camZ, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">glutSolidTeapot(<span class="number">5.0</span>);</span><br><span class="line">glDisable(GL_TEXTURE_1D);</span><br></pre></td></tr></table></figure>
<p>前 5 行代码设置了四元数组，将其记作 A B C D。</p>
<p>在眼坐标空间中生产纹理坐标时，系统在纹理坐标 S 方向进行这样的计算：<code>s = A*x + B*y + C*z + D</code>，OpenGL 的眼坐标空间向场景远处的方向为 +z 方向，将 A 和 B 设置为 0，即 x、y 方向不影响纹理坐标，只有 z 方向影响。观察 C 和 D 的计算方式，它是一个一元一次方程，斜率小于 1，s 值随着 z 的减小而增大。有点晕……冷静一下，OpenGL 的眼坐标系为左手坐标系，(0, 0, -1) 指向目标点，于是随着 z 值增大，茶壶的颜色也就越发蓝。</p>
<p>相关资料：</p>
<ul>
<li><a href="https://open.gl/textures" target="_blank" rel="external">Textures objects and parameters</a></li>
<li><a href="https://en.wikibooks.org/wiki/OpenGL_Programming/Intermediate/Textures" target="_blank" rel="external">OpenGL Programming/Intermediate/Textures</a></li>
<li><a href="http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-5-a-textured-cube/" target="_blank" rel="external">OpenGL tutorial 第五课：带纹理的立方体</a></li>
<li><a href="https://www.opengl.org/sdk/docs/man2/xhtml/gluBuild2DMipmaps.xml" target="_blank" rel="external">gluBuild2DMipmaps — builds a two-dimensional mipmap</a></li>
<li><a href="http://www.cnitblog.com/linghuye/archive/2005/08/13/1856.aspx" target="_blank" rel="external">OpenGL多重纹理使用与理解</a></li>
<li><a href="http://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20040914" target="_blank" rel="external">第２回 テクスチャの割り当て</a></li>
<li><a href="http://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20040917" target="_blank" rel="external">第５回 テクスチャ座標</a></li>
<li><a href="http://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20040212" target="_blank" rel="external">とっても簡単なマルチテクスチャのサンプル</a></li>
<li><a href="https://www.opengl.org/archives/resources/faq/technical/texture.htm" target="_blank" rel="external">OpenGl FAQ - Texture Mapping</a></li>
<li><a href="http://www.glprogramming.com/red/chapter09.html" target="_blank" rel="external">OpenGL Programming Guide Chapter 9 - Texture Mapping</a></li>
<li><a href="http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Chapter-2.1:-Buffers-and-Textures.html" target="_blank" rel="external">An intro to modern OpenGL. Chapter 2.1: Buffers and Textures</a></li>
<li><a href="https://www.cs.umd.edu/users/mount/427/OpenGL/ogl_ref/node14.html" target="_blank" rel="external">Texture Mapping</a></li>
<li><a href="http://my.oschina.net/sweetdark/blog/176407#OSC_h4_1" target="_blank" rel="external">OpenGL超级宝典笔记——纹理映射（二）</a></li>
<li><a href="http://www.cs.uregina.ca/Links/class-info/405/WWW/Lab5/moreontexturemap.html" target="_blank" rel="external">More Info on Texture Mapping</a></li>
<li><a href="http://www.3dgep.com/texturing-and-lighting-with-opengl-and-glsl/" target="_blank" rel="external">Texturing and Lighting with OpenGL and GLSL</a></li>
<li><a href="http://marina.sys.wakayama-u.ac.jp/~tokoi/?date=20041228" target="_blank" rel="external">第７回 テクスチャ座標の自動生成</a></li>
<li><a href="http://web.engr.oregonstate.edu/~mjb/chromadepth/chromapaper.pdf" target="_blank" rel="external">Using ChromaDepth to obtain Inexpensive Single-image Stereovision for Scientific Visualization</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="2D__u7EB9_u7406_u6620_u5C04"><a href="#2D__u7EB9_u7406_u6620_u5C04" class="headerlink" title="2D 纹理映射"></a>2D 纹理映射</h1><p>纹理映射一般是在图形的坐标值已经计算完成时附加在顶点信息上的，而非对纹理进行透视、变换再显示。下面逐步介绍如何在 OpenGL 中开启纹理映射，它的顺序有先后但并不唯一，若是想颠倒一下顺序也不妨试试看会有什么效果🙃️</p>
<h2 id="u8BFB_u53D6_u7EB9_u7406_u56FE"><a href="#u8BFB_u53D6_u7EB9_u7406_u56FE" class="headerlink" title="读取纹理图"></a>读取纹理图</h2><p>纹理图的格式一般为原始 RGB 格式，一个字节（8 bits）代表一种颜色通道，一个像素的颜色用三个字节表示，例如白色记为 <code>#FFFFFF</code>，是不是很熟悉，这种表示方式即 RGB888，由或者称其为 24 位真彩色。除此之外还有一些其他常用的格式：RGBA8888，RGB565，RGBA5551……</p>
<p>纹理图通常是正方形，若图形 API 没有严格限制，也可以为矩形。大多数图形卡及图形 API 为了效率的原因，限制图像分辨率为 2 的幂，例如 256*256，具体要求请参考文档。</p>
<p><img src="http://ww4.sinaimg.cn/large/72d7aee5jw1f068lt6aaaj218v0qaqar.jpg" alt="Photoshop 导出原始 RGB 图像"></p>
<p>这里我们使用 Photoshop 将图片裁剪成 512*512 分辨率，然后将其导出为原始 RGB 格式的图像，只要在存储时选择 Photoshop raw 格式即可（别和单反的那种 RAW 搞混了哦）。导出后的文件记录着自左上角向右下角逐行扫描的 RGB 信息。</p>
<p><img src="http://ww2.sinaimg.cn/large/72d7aee5jw1f068pzyeqxj20te0itwm5.jpg" alt="查看 RAW 文件"></p>
<p>使用十六进制文本查看器查看导出的文件，可以看到共 512*512*3 = 786432 字节，查看前三个字节组成的颜色 <code>#444135</code>，大致是深褐色。</p>]]>
    
    </summary>
    
      <category term="OpenGL" scheme="http://mainasuk.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OpenGL 鼠标拾取漫谈]]></title>
    <link href="http://mainasuk.com/2016/01/18/OpenGLPicking/"/>
    <id>http://mainasuk.com/2016/01/18/OpenGLPicking/</id>
    <published>2016-01-18T11:09:00.000Z</published>
    <updated>2016-01-21T07:58:19.000Z</updated>
    <content type="html"><![CDATA[<p>OpenGL 有多种方法可以实现鼠标拾取物体，其中的两种方法比较常用。第一种通常被认为是标准的选择方法，它跟踪被选中像素或包括其周围的一小片区域的所有对象，接下来具体介绍这种方法。第二种是选取一个颜色集，用互不相同的颜色绘制可以被选中的对象，通过检查选中点的颜色缓存的颜色来识别出选择对象。</p>
<h3 id="u5BF9_u8C61"><a href="#u5BF9_u8C61" class="headerlink" title="对象"></a>对象</h3><p>我们抽象地认为在 <code>glBegin(…)</code> 和 <code>glEnd()</code> 之间绘制的图形为一个对象，它存在于世界坐标系中。通过投影和变换将其转化为图像绘制在屏幕上后，如何通过鼠标选中的屏幕上的像素点来选中一个存在于三维世界坐标系的物体呢，OpenGL 提出了一种强大的解决方案供我们使用。</p>
<h3 id="u540D_u79F0"><a href="#u540D_u79F0" class="headerlink" title="名称"></a>名称</h3><p>首先我们区分出可以被选中的物体，将它赋予一个名称（name），在绘制过程中，如果有名称的对象覆盖了选中的像素点，则将名称保存到一个选择缓存中。有趣的是，我们还可以使用层次结构的名称来命名一个物体，对于一辆汽车，我们可以说选中了一个车门，或者选中了一辆汽车，这为我们调整选中的精细度提供了可能。</p>
<p>虽然说是一个 name，但实际上是一个无符号整形（GLuint），用枚举来表示的话确实和名称差不多，嘛～</p>
<h3 id="u540D_u79F0_u6808"><a href="#u540D_u79F0_u6808" class="headerlink" title="名称栈"></a>名称栈</h3><p>OpenGL 使用栈来保存名称，称其为名称栈（name stack），当绘制到选中的像素点时，则将栈中的全部信息都保存到选择缓存内，理解这个操作对理解拾取的实现是至关重要的。上面所说的层次结构就是使用压栈、出栈的方法实现的。</p>
<h3 id="u9009_u62E9_u7F13_u5B58"><a href="#u9009_u62E9_u7F13_u5B58" class="headerlink" title="选择缓存"></a>选择缓存</h3><p>选择缓存是一个 GLuint 类型的数组，由用户创建，通过 <code>glSelectBuffer(GLsizei size, GLuint *buffer)</code> 函数完成缓存设置。设置完毕后，API 在绘制时将会自动完成名称的记录工作，选择缓存的结构大致如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/72d7aee5jw1f03s38pq40j20sg0lcq3k.jpg" alt="选择缓存"></p>
<p>当对象绘制过程中覆盖到选中点时，名称栈中的信息将自动添加到选择缓存中，名称表的长度由名称数确定，若多于一个名称的，按名称添加的层次顺序排序，即先添加（入栈）的名称排在前；<code>zmin</code> 和 <code>zmax</code> 记录该对象在深度缓冲中的高度，离视点越远数值越大。</p>
<p>选择缓存中的每一个对象的相关信息可由 [3+N] 个无符号整型值表示，当我们不使用层次结构的名称来命名时，可以认为第 i 个对象的名称为 buf[i][3]。</p>
<a id="more"></a>
<h3 id="u7ED8_u5236"><a href="#u7ED8_u5236" class="headerlink" title="绘制"></a>绘制</h3><p>OpenGL 使用 <code>glRenderMode(mode)</code> 设置绘制模式／光栅化模式，它的返回值由上一次调用的 <code>mode</code> 参数确定，不同的模式下进行绘图操作会有不同的行为。当设置为 <code>GL_RENDER</code> （默认模式）时，绘制的物体将会被显示出来，而设置为 <code>GL_SELECT</code> 时，帧缓冲（Frame buffer）不会更新，重绘的内容相当于不可见的，若先前设置好了选择缓存，切换到 <code>GL_RENDER</code> 模式时返回值即选择缓存中的对象数。</p>
<p>通常情况下，在选择模式中我们重新设置透视矩阵和模视矩阵，在设置透视之前调用 <code>glPickMatrix(…)</code> 设置拾取矩阵完成裁剪，这样可以将绘图的工作量减小；进一步考虑，可以使用一些简单的几何对象来近似表示模型，甚至可以让用户选择一些看不到的物体（隐藏道具？）；对于 OpenGL 渲染的不可选择的 GUI 文本对象，也可以使用类似的思路使其表现为可选的。</p>
<h3 id="u4EA4_u4E92"><a href="#u4EA4_u4E92" class="headerlink" title="交互"></a>交互</h3><p>得到所选对象的名称后就可以在绘制时操纵对象。我见到过一个很炫的用例，它绘制一个贝塞尔曲面，用户可以通过鼠标选中并移动锚点，随着锚点移动，曲面也随着变化。</p>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><p>移除掉无关代码后，一个简单示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GLUT/GLUT.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N_ROWS      <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N_COLS      <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CUBE_SIZE   <span class="number">.5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BUFF_SIZE   <span class="number">100</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PICK_TOL    <span class="number">10</span></span></span><br><span class="line"></span><br><span class="line">GLuint hit;</span><br><span class="line">GLuint selectBuffer[BUFF_SIZE];</span><br><span class="line">GLint viewport[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(GLenum mode)</span></span>;</span><br><span class="line"><span class="function">GLuint <span class="title">doSelect</span><span class="params">(GLint x, GLint y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    hit = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    render(GL_RENDER);</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(GLenum mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> name = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N_ROWS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N_COLS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mode == GL_SELECT) &#123;</span><br><span class="line">                glLoadName(name++);</span><br><span class="line">            &#125;</span><br><span class="line">            glPushMatrix();</span><br><span class="line">            &#123;</span><br><span class="line">                glTranslatef(<span class="number">2</span>*i*CUBE_SIZE, <span class="number">0.0</span>, <span class="number">2</span>*j*CUBE_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (hit == i*N_ROWS + j%N_COLS) &#123;</span><br><span class="line">                    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, redColor);</span><br><span class="line">                    glutSolidCube(CUBE_SIZE);</span><br><span class="line">                    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, greenColor);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    glutSolidCube(CUBE_SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">                glPopName();</span><br><span class="line">            &#125;</span><br><span class="line">            glPopMatrix();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">doSelect</span><span class="params">(GLint x, GLint y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    GLint dx, dy;</span><br><span class="line">    GLint hits, tempHit;</span><br><span class="line">    GLuint zVal;</span><br><span class="line">    </span><br><span class="line">    dx = glutGet(GLUT_WINDOW_WIDTH);</span><br><span class="line">    dy = glutGet(GLUT_WINDOW_HEIGHT);</span><br><span class="line">    </span><br><span class="line">    glSelectBuffer(BUFF_SIZE, selectBuffer);</span><br><span class="line">    glRenderMode(GL_SELECT);</span><br><span class="line">    glInitNames();</span><br><span class="line">    glPushName(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Set up view model</span></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    &#123;</span><br><span class="line">        glMatrixMode(GL_PROJECTION);</span><br><span class="line">        glLoadIdentity();</span><br><span class="line">        gluPickMatrix(x, dy - y, PICK_TOL, PICK_TOL, viewport);</span><br><span class="line">        gluPerspective(<span class="number">60.0</span>, (GLfloat)windowW/(GLfloat)windowH, <span class="number">1.0</span>, <span class="number">30.0</span>);</span><br><span class="line">        glMatrixMode(GL_MODELVIEW);</span><br><span class="line">        glLoadIdentity();</span><br><span class="line">        <span class="comment">//          eye point   center of view      up</span></span><br><span class="line">        gluLookAt(camX, camY, camZ, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        </span><br><span class="line">        render(GL_SELECT);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    glPopMatrix();</span><br><span class="line">    </span><br><span class="line">    hits = glRenderMode(GL_RENDER);</span><br><span class="line">    </span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluPerspective(<span class="number">60.0</span>, (GLfloat)windowW/(GLfloat)windowH, <span class="number">1.0</span>, <span class="number">30.0</span>);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    <span class="comment">//          eye point   center of view      up</span></span><br><span class="line">    gluLookAt(camX, camY, camZ, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hits &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zVal = selectBuffer[<span class="number">1</span>];</span><br><span class="line">        tempHit = selectBuffer[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; hits; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectBuffer[<span class="number">4</span>*i+<span class="number">1</span>] &lt; zVal) &#123;</span><br><span class="line">                zVal = selectBuffer[<span class="number">4</span>*i+<span class="number">1</span>];</span><br><span class="line">                tempHit = selectBuffer[<span class="number">4</span>*i+<span class="number">3</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tempHit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">if</span> (state == GLUT_DOWN) &#123;</span><br><span class="line">        hit = doSelect((GLint) x, (GLint)y);</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在鼠标点击事件中调用了 <code>doSelect</code> 方法：切换到选择模式后重画视图，接着切换回来，得到选中的名称并返回。在绘制函数中对选中对象设置不同的材质便得到了下面的效果。</p>
<p><img src="http://ww1.sinaimg.cn/large/72d7aee5jw1f03ulq5kbfj20pc0keq6a.jpg" alt="Select Demo"></p>
<p>通过改变绘制的分支语句，也可以实现多选或选择一行的功能。在命名时如果仔细小心，也可以实现分层选择的功能。</p>
<h4 id="u4E00_u4E2A_u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u4E00_u4E2A_u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="一个参考资料："></a>一个参考资料：</h4><ul>
<li><a href="http://web.cse.ohio-state.edu/~hwshen/581/Site/Slides_files/picking.pdf" target="_blank" rel="external">OpenGL Picking</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenGL 有多种方法可以实现鼠标拾取物体，其中的两种方法比较常用。第一种通常被认为是标准的选择方法，它跟踪被选中像素或包括其周围的一小片区域的所有对象，接下来具体介绍这种方法。第二种是选取一个颜色集，用互不相同的颜色绘制可以被选中的对象，通过检查选中点的颜色缓存的颜色来识别出选择对象。</p>
<h3 id="u5BF9_u8C61"><a href="#u5BF9_u8C61" class="headerlink" title="对象"></a>对象</h3><p>我们抽象地认为在 <code>glBegin(…)</code> 和 <code>glEnd()</code> 之间绘制的图形为一个对象，它存在于世界坐标系中。通过投影和变换将其转化为图像绘制在屏幕上后，如何通过鼠标选中的屏幕上的像素点来选中一个存在于三维世界坐标系的物体呢，OpenGL 提出了一种强大的解决方案供我们使用。</p>
<h3 id="u540D_u79F0"><a href="#u540D_u79F0" class="headerlink" title="名称"></a>名称</h3><p>首先我们区分出可以被选中的物体，将它赋予一个名称（name），在绘制过程中，如果有名称的对象覆盖了选中的像素点，则将名称保存到一个选择缓存中。有趣的是，我们还可以使用层次结构的名称来命名一个物体，对于一辆汽车，我们可以说选中了一个车门，或者选中了一辆汽车，这为我们调整选中的精细度提供了可能。</p>
<p>虽然说是一个 name，但实际上是一个无符号整形（GLuint），用枚举来表示的话确实和名称差不多，嘛～</p>
<h3 id="u540D_u79F0_u6808"><a href="#u540D_u79F0_u6808" class="headerlink" title="名称栈"></a>名称栈</h3><p>OpenGL 使用栈来保存名称，称其为名称栈（name stack），当绘制到选中的像素点时，则将栈中的全部信息都保存到选择缓存内，理解这个操作对理解拾取的实现是至关重要的。上面所说的层次结构就是使用压栈、出栈的方法实现的。</p>
<h3 id="u9009_u62E9_u7F13_u5B58"><a href="#u9009_u62E9_u7F13_u5B58" class="headerlink" title="选择缓存"></a>选择缓存</h3><p>选择缓存是一个 GLuint 类型的数组，由用户创建，通过 <code>glSelectBuffer(GLsizei size, GLuint *buffer)</code> 函数完成缓存设置。设置完毕后，API 在绘制时将会自动完成名称的记录工作，选择缓存的结构大致如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/72d7aee5jw1f03s38pq40j20sg0lcq3k.jpg" alt="选择缓存"></p>
<p>当对象绘制过程中覆盖到选中点时，名称栈中的信息将自动添加到选择缓存中，名称表的长度由名称数确定，若多于一个名称的，按名称添加的层次顺序排序，即先添加（入栈）的名称排在前；<code>zmin</code> 和 <code>zmax</code> 记录该对象在深度缓冲中的高度，离视点越远数值越大。</p>
<p>选择缓存中的每一个对象的相关信息可由 [3+N] 个无符号整型值表示，当我们不使用层次结构的名称来命名时，可以认为第 i 个对象的名称为 buf[i][3]。</p>]]>
    
    </summary>
    
      <category term="OpenGL" scheme="http://mainasuk.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可视化超立方体]]></title>
    <link href="http://mainasuk.com/2016/01/13/HypercubeVisualize/"/>
    <id>http://mainasuk.com/2016/01/13/HypercubeVisualize/</id>
    <published>2016-01-13T08:36:00.000Z</published>
    <updated>2016-01-13T08:54:11.000Z</updated>
    <content type="html"><![CDATA[<p>读过《思考的乐趣》的朋友一定还记得最后一章中那个令人匪夷所思的四维超立方体（<a href="https://zh.wikipedia.org/wiki/超方形" target="_blank" rel="external">hypercube</a>），生活在三维世界中的我们居然也可以去想象更高维的空间，真是有趣。</p>
<h1 id="u5EFA_u6A21"><a href="#u5EFA_u6A21" class="headerlink" title="建模"></a>建模</h1><p>可视化的第一步就是建模，类似于三维立方体，用四维坐标（x, y, z, w）表示超立方体的顶点。按照每增加一个维度，顶点数翻倍的规律来看，超立方体的顶点是立方体的两倍，即 16 个顶点。一种典型的超立方体的所有顶点可由下表列出。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">Vertex</th>
<th style="text-align:center">X</th>
<th style="text-align:center">Y</th>
<th style="text-align:center">Z</th>
<th style="text-align:center">W    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
</tbody>
</table>
<p>可以看到前 8 个顶点的 w 坐标值为 0，也就是说用这八个点去取出超立方体的一个超平面（hyperplane），这个超平面就是一个立方体。类似的，它有 32 条边，24 个面。</p>
<p>对边进行考虑，可以发现 12 条边构成一个立方体，将表格前八个顶点构成的立方体的 w 值设为 1（或者说将它沿 w 轴平移），将得到的几何体的每个顶点与变换前的顶点相连，计算边数得 12＋12+8 ＝ 32 条边。</p>
<p>利用离散数学的知识，我们可以建立顶点集和边集，用以表示一个超立方体。在绘制时将遍历边集，绘制出所有边，完成可视化的工作。</p>
<h2 id="u6295_u5F71"><a href="#u6295_u5F71" class="headerlink" title="投影"></a>投影</h2><p>类似在纸面上绘制立方体，我们将超立方体投影（projection）到三维空间，从而达到可视化的目的。若沿着 w 轴进行平行投影，可直接得出一个立方体，它们的顶点是重叠的（<a href="http://hypersolid.milosz.ca" target="_blank" rel="external">请参考这里</a>）。</p>
<p>在可视化的同时为了便于观察和理解，我们将顶点的 w 值均匀(若可以动态旋转并投影，则是否为 1/3 就不重要了)的投影在其余坐标轴上。比如 P(x, y, z, w) 变换到 P(x-(1/3)w, y-(1/3)w, z-(1/3)w)。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/72d7aee5jw1ezxywm31shg20i20fhk42.gif" alt="将超立方体进行简单的投影"></p>
<p>这里的几何体仅仅进行了 xyz 轴的旋转，换句话说，只移动了摄像机。</p>
<h2 id="u65CB_u8F6C"><a href="#u65CB_u8F6C" class="headerlink" title="旋转"></a>旋转</h2><p>利用 OpenGL 的工具函数可以方便的沿着某个轴进行旋转，所以沿着 x、y、z 轴旋转几何体是很方便的，旋转的结果也是易于理解的。若将 w 轴考虑在内的话，就必须要手工进行模型变换了，以 XW 旋转为例，使用变换矩阵：</p>
<pre><code>[cos(t)    0    0    sin(t)
   0       1    0       0
   0       0    1       0
 -sin(t)   0    0    cos(t)]
</code></pre><p>将模型中的点通过与变换矩阵相乘，所得点即为旋转后的点。之后进行投影和绘制。</p>
<h2 id="u751F_u6210_u7ED3_u679C"><a href="#u751F_u6210_u7ED3_u679C" class="headerlink" title="生成结果"></a>生成结果</h2><p><img src="http://ww2.sinaimg.cn/mw690/72d7aee5jw1ezxywhcvmsg20fo0f9wmc.gif" alt="对超立方体进行 XW 旋转"></p>
<p>啊呀～和 Wiki 里的 <a href="https://zh.wikipedia.org/wiki/超方形#/media/File:8-cell.gif" target="_blank" rel="external">GIF</a> 图不太像，修改一下投影方法，完成～</p>
<p><img src="http://ww2.sinaimg.cn/mw690/72d7aee5jw1ezxywt0vcqg20hk0ebts2.gif" alt="旋转中的超立方体"></p>
<p>不过，就算投影看上去是一个立方体嵌套在另一个里面，实际上却根本不是那回事。（至于旋转 XW 实际上发生了什么，对照下面链接中的平行坐标系大概就能看懂了。）</p>
<p>这里有一个不错的演示工具，可以提供参考：<br><a href="http://exposedata.com/hypercube/rotate/" target="_blank" rel="external">http://exposedata.com/hypercube/rotate/</a></p>
<h3 id="u76F8_u5173_u8D44_u6599"><a href="#u76F8_u5173_u8D44_u6599" class="headerlink" title="相关资料"></a>相关资料</h3><ol>
<li><a href="https://andrewharvey4.wordpress.com/2008/10/21/an-introduction-to-hypercubes/" target="_blank" rel="external">An Introduction to Hypercubes</a></li>
<li><a href="http://www.interactiveds.com.au/images/4D.htm" target="_blank" rel="external">Four dimensions has three rotational states</a></li>
<li><a href="http://www.geom.uiuc.edu/docs/outreach/4-cube/cubed.txt.html" target="_blank" rel="external">Rotation of a tesseract</a></li>
<li><a href="http://www.well.com/~abs/SIGGRAPH96/4Dtess.html" target="_blank" rel="external">Visualizing 4D Hypercube Data By Mapping Onto a 3D Tesseract - SIGGRAPH</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.2254&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">A METHOD FOR OBTAINING THE TESSERACT BY UNRAVELING THE 4D HYPERCUBE</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>读过《思考的乐趣》的朋友一定还记得最后一章中那个令人匪夷所思的四维超立方体（<a href="https://zh.wikipedia.org/wiki/超方形">hypercube</a>），生活在三维世界中的我们居然也可以去想象更高维的空间，真是有趣。</p>
<h1 id="u5EFA_u6A21"><a href="#u5EFA_u6A21" class="headerlink" title="建模"></a>建模</h1><p>可视化的第一步就是建模，类似于三维立方体，用四维坐标（x, y, z, w）表示超立方体的顶点。按照每增加一个维度，顶点数翻倍的规律来看，超立方体的顶点是立方体的两倍，即 16 个顶点。一种典型的超立方体的所有顶点可由下表列出。</p>]]>
    
    </summary>
    
      <category term="Math" scheme="http://mainasuk.com/tags/Math/"/>
    
      <category term="OpenGL" scheme="http://mainasuk.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 汇编初体验与计算的目的]]></title>
    <link href="http://mainasuk.com/2015/12/25/Linux-assemble-and-Compute/"/>
    <id>http://mainasuk.com/2015/12/25/Linux-assemble-and-Compute/</id>
    <published>2015-12-25T02:30:00.000Z</published>
    <updated>2015-12-27T15:35:18.000Z</updated>
    <content type="html"><![CDATA[<p>说起来真的让人难以置信，我校汇编教材是老师自己写自己印的，拿到手的时候不由得想起高中在学校自己的印刷室里帮老师装订复习资料的场景……</p>
<p>好吧，Windows 系统下 的 DEBUG 只能说是勉强够用。先在记事本里写好程序，之后一行行敲入 DEBUG 下，调试起来甚至会简单一些。更进一步，用 MASA 和 LINK 也可以直接将汇编源文件编译成可执行文件。不过这里我以 Linux 为基础，如果对汇编有兴趣，可以尝试着写几个有用的程序，比如说～嗯， <code>0A</code> 与 <code>0D 0A</code> 间自由转换的转换器？</p>
<p>&gt; 从字节层面看文本文件，Windows 操作系统以 0D 0A（16进制）作为换行标记（End of Line，EOL），而 Linux 则以 0A 作为 EOL。于是，Linux 下编写的文本文件在 Windows 的记事本中会丢失换行符。乱码？噢，不不不，那是因为 Linux 以 Unicode 保存汉字，而 Windows 记事本以 GBK 编码去解析造成的，对于中文世界，情况大多如此。</p>
<a id="more"></a>
<h1 id="u73AF_u5883_u90E8_u7F72"><a href="#u73AF_u5883_u90E8_u7F72" class="headerlink" title="环境部署"></a>环境部署</h1><p>编写 Linux 汇编程序，首先需要一个你有一个基于 Intel CPU 的 Linux 系统。如果可以满足这点，恭喜，您已经达到基本的硬件要求了。这里我使用 Ubuntu 14.04 LTS 64 位发行版，它运行在一台超便宜的洋垃圾笔记本上:D</p>
<h2 id="u5DE5_u5177_u94FE"><a href="#u5DE5_u5177_u94FE" class="headerlink" title="工具链"></a>工具链</h2><ul>
<li>NASM 汇编编译器</li>
<li>ld 连接器</li>
<li>Gdb 调试器</li>
</ul>
<p>为了更好的编辑与调试，我使用 Kate 文本编辑器，安装 KWrite 文本编辑器后在 Kate 中添加终端插件（为了使用一个编辑器的插件需要另一个编辑器……呃，若终端插件无法工作，请安装 Konsole）。</p>
<p><img src="http://ww3.sinaimg.cn/large/72d7aee5gw1ezbnbozglqj20zk0m8dlv.jpg" alt="Kate"><br>（我想了半天风筝和它的联系，结果一点没有 OAO）</p>
<p>最后使用 Insight 作为 Gdb 的前端，如果感觉安装麻烦，使用 Kdbg 似乎也不错，只是对于汇编的支持差一些。好极了，现在我们有一个 GUI 的调试窗口用了。</p>
<p><img src="http://ww2.sinaimg.cn/large/72d7aee5gw1ezbn45fan5j20zk0m8afu.jpg" alt="Kdbg"></p>
<p><img src="http://ww3.sinaimg.cn/large/72d7aee5gw1ezbol3vh4cj20zk0m84ci.jpg" alt="insight"></p>
<h2 id="u5F00_u59CB_u4E4B_u524D"><a href="#u5F00_u59CB_u4E4B_u524D" class="headerlink" title="开始之前"></a>开始之前</h2><p>在编写汇编代码之前稍稍暂停一下，汇编语言到底是什么？在高级语言中，我们可以直接定义变量和函数，但是汇编语言中，没有那种方便的东西，我们能操纵的东西只有数字，除了数字……还是数字。</p>
<p>不过实际上我们还是有类似变量的东西，寄存器。在过去 Intel 的 CPU 还是 8080 的时候，操作系统（CP/M-80）简单的安装在内存的顶部，内存底部的 256 字节用做程序段前缀（Program Segment Prifix，PSP），存储一些杂碎。程序从软盘中读入，加载到内存地址 0x0100 处，当程序运行时，操作系统直接对 0x0100 进行寻址。</p>
<p>CPU 从内存中寻址，得到机器指令，然后依照指令进行运算。<a href="https://en.wikipedia.org/wiki/Intel_8080#/media/File:Intel_8080_arch.svg" target="_blank" rel="external">8080 CPU</a> 有 7 个寄存器用来存放运算数，它们的大小只有 8 位（没错，也就是说它的 CPU 是 8 位的）。它有 16 根地址线，8 根数据线。与地址线连接的是一个 16 位的地址缓存（Address Buffer），意味着它的寻址大小是 64K（0 – 65536）。</p>
<p><img src="http://ww3.sinaimg.cn/large/72d7aee5gw1ezbonwimv1j20sg0lcdh4.jpg" alt="64K 内存"></p>
<p>对地址 0x0100 进行寻址时，CPU 将地址缓存设置为 <code>0000 0001 0000 0000</code>，也就是将对应的存储芯片通低电压或高电压，啊，令人头大的晶体管。16 根地址线将选择信号加在芯片的选择器上，数字电路会给指定地址的存储单元通电，拿出这 1 个 bit 的数据，当 8 个芯片串在一起时，我们便得到了 8 bit (1 字节) 的数据。这个过程仅需要不可思议的几纳秒。</p>
<p><img src="http://ww1.sinaimg.cn/large/72d7aee5gw1ezbonc1z5pj20sg0lcjsf.jpg" alt="RAM 芯片"></p>
<p>得到机器指令后，CPU 执行出厂时烧录好的指令集中的一条，而汇编语言就是直接或间接操纵（从内存拿出）数据，命令 CPU 执行计算的语言。实际上汇编语言编译后的程序代码（机器指令）也是一些 0 和 1。说白了，计算机就是在 0 和 1 之间跳舞，数据和可执行代码并没有本质的区别（想出利用缓冲区溢出漏洞攻击的人简直是天才）。</p>
<p>后来的 8086 有 20 根地址线，8 根数据线，可以在操纵 1MB 的内存（更准确的说，是 1MiB，但这里不再特意区分 MB 与 <a href="https://en.wikipedia.org/wiki/Mebibyte" target="_blank" rel="external">MiB</a>）。而今天，32 位 CPU 可以寻址 4GB 内存，64 位 CPU 的寻址大小为 2^64 = 16777216TB。当然，CPU 和内存的技术也在变化，目前内存（<a href="http://www.techbang.com/posts/18381-from-the-channel-to-address-computer-main-memory-structures-to-understand?page=1" target="_blank" rel="external">DIMM</a>）的存储单元堆叠在一起，存储单元的存储方式也不是按列存储。而多核 CPU 的出现以及多级缓存的应用使得在大脑中构建一个计算机运行的模型愈发困难，若实际去考量程序的执行效率，就不可避免的需要考虑到内存存取，缓存命中，内存一致性的诸多问题。考虑目前 CPU 的执行速度和内存存取的速度，在 CPU 不是瓶颈的场景中做到尽量少的存取内存，并且提高缓存命中率（顺序存储／压缩数据），可有效提高程序效率。</p>
<p>噢天啊～让生活简单一点吧，尽管访问内存的细节很复杂，但我们通常将它抽象成一个非常长的书架，一个物理地址对应着一个字节。不过一定要头脑清楚，除非你知道自己在做什么，否则不要试着在这个抽象层面上做任何‘优化’。</p>
<h2 id="u6C47_u7F16_u7F16_u7A0B_u6A21_u578B"><a href="#u6C47_u7F16_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="汇编编程模型"></a>汇编编程模型</h2><p>好像差不多了，不过再等一下。是的，如果你为 8 位的 Intel 8080 CPU 编写汇编程序，对 64K 内存直接寻址是可行的（实模式平面模型，real mode flat model）；若为 32位机编写程序，你也可以直接对 4GB 内存进行寻址（保护模式平面模型，protected mode flat model）。</p>
<p>为 16 位 Intel 8086 编写程序呢？它和 8080 一样使用 16 位的地址缓存，但却有 20 条数据线，可对 1MB 内存进行寻址。如何用 16 位寄存器生成 20 位地址呢？答案是出乎意料的，CPU 使用两个 16 位寄存器来计算物理地址。将 1MB 的内存分成许多段（segment），段开始的地址就是段地址，它存储在段寄存器。任何能被 16 整除的地址都可以作为段地址，范围为 <code>0x0 – 0xFFFF</code>。将段地址乘 16 再加上另一个寄存器中存储的偏移地址，就得到了一个 20 位的物理地址，常常这样表示 0042:0042。（实模式段模型，real mode segmented model）</p>
<p>当我们使用十六进制来看时，段的含义会更清楚。<code>0x42</code> 乘 16 等同于 <code>0000 0000 0400 0010</code> 左移四位，得到 <code>0x420</code>（<code>0000 0000 0400 0010 0000</code>），再加上一个 16 位偏移地址 <code>0x42</code> 等于 <code>0x462</code>（<code>0000 0000 0100 0110 0010</code>）。细心的朋友已经发现了，尽管段地址加偏移地址可以实现对 1MB 内存的寻址，但实际上物理地址所对应的实际地址并不唯一，这是由于段地址之间间隔 16 个字节，将段地址平移之后也可能会有合法的偏移地址来代表某个物理地址。而这也告诉了我们段的本质，它只是一个特殊的地址及其后面的若干字节，段的大小至多为 65535 字节（64K），段地址为 <code>0xFFFF</code> 的段的大小只有 16 字节。</p>
<p>Intel 的 CPU 有一个良好的特性（恐怕也有人对此不是很赞同），即向后兼容。目前的 CPU 的架构都是在早期的架构上不断改进，即使架构有重大的变化，暴露给系统的那一部分始终是一样的。这也就是为什么你把之前 32 位的操作系统更换为 64 位而没有任何错误发生的原因（如果有错，你也不能怪它，因为它太旧了 XD）。哦，对了，当在 Windows 下运行 DOS 时，实际上就是进入了虚拟 86 模式，因此进入 DEBUG 后就像是回到了 8086 的时代一样，我们只有 64K 内存可以使用。</p>
<p>听说 DOS 时代有很多有趣的事情可以做，比如将数据直接写入内存中与显存存在映射关系的地方，操纵内存便可以制作出一些动画。现在的操作系统采用保护模式平面模型（Protected mode flat model），它将段地址保护起来，仅由操作系统控制，系统利用它可以实现虚拟内存，保护操作系统内核。目前很多 CPU 已经寄存器都扩大为 64 位，采用长模式，除了将过去 80x86 CPU 的寄存器加长到 64 位，还增加了几个新的寄存器，它们没有提供向后兼容的特性，即只能以 64 位进行读取。除此之外，目前的 CPU 还提供了 128 位的 SSE 寄存器，可加速数学/图形计算，比如多个四元数运算（SIMD，Single Instruction Multiple Data）。</p>
<h1 id="u7F16_u5199_u4EE3_u7801"><a href="#u7F16_u5199_u4EE3_u7801" class="headerlink" title="编写代码"></a>编写代码</h1><p>现在我们可以来编写汇编程序了，尽管在 Ubuntu 64 位系统下编写，但我们还是使用 32 位汇编编译器。所以我们手里有几个 32 位寄存器，还有一些 Linux 系统调用。</p>
<figure class="highlight c++"><figcaption><span>hello.asm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">;  Program: Hello World</span><br><span class="line">;  </span><br><span class="line">;  Usage:</span><br><span class="line">;  nasm -f elf -g -F dwarf hello.<span class="keyword">asm</span></span><br><span class="line">;  ld -m elf-i386 -o hello hello.o</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">    helloMsg: db <span class="string">"Hello, world!"</span>, <span class="number">10</span></span><br><span class="line">    helloLen: equ $-HelloMsg</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">global _start:</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">        nop </span><br><span class="line">        mov eax, <span class="number">4</span>            ; sys_write</span><br><span class="line">        mov ebx, <span class="number">1</span>            ; <span class="built_in">stdout</span></span><br><span class="line">        mov ecx, helloMsg     ; message to print</span><br><span class="line">        mov edx, helloLen     ; message length </span><br><span class="line">        <span class="keyword">int</span> <span class="number">80</span>H               ; system call</span><br><span class="line">        </span><br><span class="line">        mov eax, <span class="number">1</span>            ; <span class="built_in">exit</span></span><br><span class="line">        mov ebx, <span class="number">0</span>            ; <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">int</span> <span class="number">80</span>H               ; system call</span><br><span class="line">        nop</span><br></pre></td></tr></table></figure>
<p>首先来看数据段。helloMsg 为字符串，<code>db</code> 意为 define byte，引号用来标记字符串，数字 10 是换行符标记（还记得 <code>0xOA</code> 吗）。helloLen 为字符串长度，<code>equ</code> 指令指示编译时计算它的值，$ 令牌标识记录位置，在这里，它记录着 <code>0x0A</code> 后的位置，减去 helloMsg（字符串开始位置），得到的就是字符串长度。</p>
<p>之后我们使用 <code>MOV</code> 命令（mov <em>dest</em>, <em>source</em>）将源操作数存储在目的操作数中。在这里，我们将数字 4 放置在寄存器 EAX （32 位通用寄存器，除 EAX 外，还有 EBX，ECX，EDX）中；将数字 1 放在 EBX 中；将字符串的起始地值放置在 ECX 中；将字符串长度放置在 EDX 中。<a href="http://www.int80h.org" target="_blank" rel="external">INT 80H</a> 将执行一个软件中断，它首先将下一条代码的地址压入堆栈，接着跳转到<a href="https://zh.wikipedia.org/wiki/中斷向量" target="_blank" rel="external">中断向量表</a>，中断向量引导程序跳转到 Linux 系统调用服务（执行内核空间中的代码），约定 EAX 寄存器存储服务编号，4 代表 sys_write 系统调用，EBX 指定输出为 stdout（0 代表 stdin，2 代表 stderr），ECX 和 EDX 提供字符串的开始地址和长度。当系统调用完成后，经过一些我们都不知道的操作后，数据就被打印到 stdout 中（<a href="http://rosettacode.org/wiki/Check_output_device_is_a_terminal" target="_blank" rel="external">一般为 TTY，可重定向</a>），之后将下一条代码的地址从堆栈中弹出并跳转到这个地址（IRET 指令），接着执行下一条指令。</p>
<p>类似的，服务编号 1 代表退出系统调用，EBX 存储返回值 0。若不这样结束程序，系统会抛出一个段错误（Segment fault）。至于 <code>NOP</code>，它不做任何事情，加在代码首尾是为了方便调试。</p>
<p>对于 DOS 汇编，字符串输出服务编号为 09H，字符串以 $ 符号结束（0x24）。也就是说，汇编程序不能移植。特别的，由于内核不同，Linux 汇编程序不能运行在 BSD Unix 下。</p>
<h2 id="u7F16_u8BD1_u8C03_u8BD5"><a href="#u7F16_u8BD1_u8C03_u8BD5" class="headerlink" title="编译调试"></a>编译调试</h2><p><img src="http://ww4.sinaimg.cn/large/72d7aee5gw1ezbna2jrtij20zk0m8dvm.jpg" alt="insight"></p>
<p>使用 NASM 和 ld 完成源代码的编译链接，如果是 32 位机，ld 命令可省略 -m elf_i386。编译完成后，在终端运行程序，便会得到打印结果 “Hello, world!”。</p>
<p>我们使用 insight 进行调试，可以看到程序的结构，内存由低到高排列，首先是 .text 段；其次是 .data 段；接下来是 .bss 段，尽管它是一个段，但在程序加载入内存后才会被分配空间，用来存放未初始化变量。通过 insight 还可以看到编译得到的机器指令：MOV EAX 4 编译为 <code>0x00000004B8</code>，采用<a href="https://zh.wikipedia.org/wiki/字节序" target="_blank" rel="external">小端对齐</a>。这里我使用另一个字符串，可以看到它以 <code>0x0A</code>结尾，共 14 字节。</p>
<p><img src="http://ww1.sinaimg.cn/large/72d7aee5gw1ezbpfdofzkj20sg0lcmxx.jpg" alt=""></p>
<h2 id="u8BA1_u7B97"><a href="#u8BA1_u7B97" class="headerlink" title="计算"></a>计算</h2><p>对于计算有一个很有趣的论断，不知道计算机同不同意。</p>
<blockquote>
<p>计算的目的是洞察事物本质，而不是获得数字<br>— Richard Hamming</p>
</blockquote>
<p>嘛～尽管这样说，恐怕很多事物的本质还是不能用计算去得到。有时候我也会去想象一个没有计算机的世界，是不是会更好呢。美丽的大自然？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起来真的让人难以置信，我校汇编教材是老师自己写自己印的，拿到手的时候不由得想起高中在学校自己的印刷室里帮老师装订复习资料的场景……</p>
<p>好吧，Windows 系统下 的 DEBUG 只能说是勉强够用。先在记事本里写好程序，之后一行行敲入 DEBUG 下，调试起来甚至会简单一些。更进一步，用 MASA 和 LINK 也可以直接将汇编源文件编译成可执行文件。不过这里我以 Linux 为基础，如果对汇编有兴趣，可以尝试着写几个有用的程序，比如说～嗯， <code>0A</code> 与 <code>0D 0A</code> 间自由转换的转换器？</p>
<p>&gt; 从字节层面看文本文件，Windows 操作系统以 0D 0A（16进制）作为换行标记（End of Line，EOL），而 Linux 则以 0A 作为 EOL。于是，Linux 下编写的文本文件在 Windows 的记事本中会丢失换行符。乱码？噢，不不不，那是因为 Linux 以 Unicode 保存汉字，而 Windows 记事本以 GBK 编码去解析造成的，对于中文世界，情况大多如此。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://mainasuk.com/tags/Linux/"/>
    
      <category term="汇编" scheme="http://mainasuk.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="计算机" scheme="http://mainasuk.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
</feed>
