<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Below the horizon]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://mainasuk.com/"/>
  <updated>2016-01-18T11:28:47.000Z</updated>
  <id>http://mainasuk.com/</id>
  
  <author>
    <name><![CDATA[MainasuK]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[OpenGL 鼠标拾取漫谈]]></title>
    <link href="http://mainasuk.com/2016/01/18/OpenGLPicking/"/>
    <id>http://mainasuk.com/2016/01/18/OpenGLPicking/</id>
    <published>2016-01-18T11:09:00.000Z</published>
    <updated>2016-01-18T11:28:47.000Z</updated>
    <content type="html"><![CDATA[<p>OpenGL 有多种方法可以实现鼠标拾取物体，其中的两种方法比较常用。第一种通常被认为是标准的选择方法，它跟踪被被选中像素或包括其周围的一小片区域的所有对象，接下来具体介绍这种方法。第二种是选取一个颜色集，用互不相同的颜色绘制可以被选中的对象，通过检查选中点的颜色缓存的颜色来识别出选择对象。</p>
<h3 id="u5BF9_u8C61"><a href="#u5BF9_u8C61" class="headerlink" title="对象"></a>对象</h3><p>我们抽象的认为在 <code>glBegin(…)</code> 和 <code>glEnd()</code> 之间绘制的图形为一个对象，它存在于世界坐标系中。通过投影和变换将其转化为图像绘制在屏幕上后，如何通过鼠标选中的屏幕上的像素点来选中一个存在于三维世界坐标系的物体呢，OpenGL 提出了一种强大的解决方案供我们使用。</p>
<h3 id="u540D_u79F0"><a href="#u540D_u79F0" class="headerlink" title="名称"></a>名称</h3><p>首先我们区分出可以被选中的物体，将它赋予一个名称（name），在绘制过程中，如果有名称的对象覆盖了选中的像素点，则将名称保存到一个选择缓存中。有趣的是，我们还可以使用层次结构的名称来命名一个物体，对于一辆汽车，我们可以说选中了一个车门，或者选中了一辆汽车，这为我们调整选中的精细度提供了可能。</p>
<p>虽然说是一个 name，但实际上是一个无符号整形（GLuint），用枚举来表示的话确实和名称差不多，嘛～</p>
<h3 id="u540D_u79F0_u6808"><a href="#u540D_u79F0_u6808" class="headerlink" title="名称栈"></a>名称栈</h3><p>OpenGL 使用栈来保存名称，称其为名称栈（name stack），当绘制到选中的像素点时，则将栈中的全部信息都保存到选择缓存内，理解这个操作对理解拾取的实现是至关重要的。</p>
<h3 id="u9009_u62E9_u7F13_u5B58"><a href="#u9009_u62E9_u7F13_u5B58" class="headerlink" title="选择缓存"></a>选择缓存</h3><p>选择缓存是一个 GLuint 类型的数组，由用户创建，通过 <code>glSelectBuffer(GLsizei size, GLuint *buffer)</code> 函数完成缓存设置。设置完毕后，API 在绘制时将会自动完成名称的记录工作，选择缓存的结构大致如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/72d7aee5jw1f03s38pq40j20sg0lcq3k.jpg" alt="选择缓存"></p>
<p>当对象绘制过程中覆盖到选中点时，名称栈中的信息将自动添加到选择缓存中，名称表的长度由名称数确定，若多于一个名称的，按名称添加的层次顺序排序，即先添加的名称排在前；<code>zmin</code> 和 <code>zmax</code> 记录该对象在深度缓冲中的高度，离视点越远数值越大。</p>
<p>选择缓存中的每一个对象的相关信息可由 [3+N] 个无符号整型值表示，当我们不使用层次结构的名称来命名时，可以认为第 i 个对象的名称为 buf[i][3]。</p>
<h3 id="u7ED8_u5236"><a href="#u7ED8_u5236" class="headerlink" title="绘制"></a>绘制</h3><p>OpenGL 使用 <code>glRenderMode(mode)</code> 设置绘制模式／光栅化模式，它的返回值由上一次调用的 <code>mode</code> 参数确定，不同的模式下进行绘图操作会有不同的行为。当设置为 <code>GL_RENDER</code> （默认模式）时，绘制的物体将会被显示出来，而设置为 <code>GL_SELECT</code> 时，帧缓冲（Frame buffer）不会更新，重绘的内容相当于不可见的，若先前设置好了选择缓存，切换到 <code>GL_RENDER</code> 模式时返回值即选择缓存中的对象数。</p>
<p>通常情况下，在选择模式中我们重新设置透视矩阵和模视矩阵，在设置透视之前调用 <code>glPickMatrix(…)</code> 设置拾取矩阵完成裁剪，这样可以将绘图的工作量减小；进一步考虑，可以使用一些简单的几何对象来近似表示模型，甚至可以让用户选择一些看不到的物体（隐藏道具？）；对于 OpenGL 渲染的不可选择的 GUI 文本对象，也可以使用类似的思路使其表现为可选的。</p>
<h3 id="u4EA4_u4E92"><a href="#u4EA4_u4E92" class="headerlink" title="交互"></a>交互</h3><p>得到所选对象的名称后就可以在绘制时操纵对象。我见到过一个很炫的用例，它绘制一个贝塞尔曲面，用户可以通过鼠标选中并移动锚点，随着锚点移动，曲面也随着变化。</p>
<h3 id="u4EE3_u7801"><a href="#u4EE3_u7801" class="headerlink" title="代码"></a>代码</h3><p>移除掉无关代码后，一个简单示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;GLUT/GLUT.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N_ROWS      <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> N_COLS      <span class="number">10</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> CUBE_SIZE   <span class="number">.5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> BUFF_SIZE   <span class="number">100</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> PICK_TOL    <span class="number">10</span></span></span><br><span class="line"></span><br><span class="line">GLuint hit;</span><br><span class="line">GLuint selectBuffer[BUFF_SIZE];</span><br><span class="line">GLint viewport[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(GLenum mode)</span></span>;</span><br><span class="line"><span class="function">GLuint <span class="title">doSelect</span><span class="params">(GLint x, GLint y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    glutMainLoop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    hit = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    render(GL_RENDER);</span><br><span class="line">    glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">animate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(GLenum mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> name = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N_ROWS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N_COLS; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mode == GL_SELECT) &#123;</span><br><span class="line">                glLoad(name++);</span><br><span class="line">            &#125;</span><br><span class="line">            glPushMatrix();</span><br><span class="line">            &#123;</span><br><span class="line">                glTranslatef(<span class="number">2</span>*i*CUBE_SIZE, <span class="number">0.0</span>, <span class="number">2</span>*j*CUBE_SIZE);</span><br><span class="line">                <span class="keyword">if</span> (hit == i*N_ROWS + j%N_COLS) &#123;</span><br><span class="line">                    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, redColor);</span><br><span class="line">                    glutSolidCube(CUBE_SIZE);</span><br><span class="line">                    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, greenColor);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    glutSolidCube(CUBE_SIZE);</span><br><span class="line">                &#125;</span><br><span class="line">                glPopName();</span><br><span class="line">            &#125;</span><br><span class="line">            glPopMatrix();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    glPopMatrix();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">doSelect</span><span class="params">(GLint x, GLint y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    GLint dx, dy;</span><br><span class="line">    GLint hits, tempHit;</span><br><span class="line">    GLuint zVal;</span><br><span class="line">    </span><br><span class="line">    dx = glutGet(GLUT_WINDOW_WIDTH);</span><br><span class="line">    dy = glutGet(GLUT_WINDOW_HEIGHT);</span><br><span class="line">    </span><br><span class="line">    glSelectBuffer(BUFF_SIZE, selectBuffer);</span><br><span class="line">    glRenderMode(GL_SELECT);</span><br><span class="line">    glInitNames();</span><br><span class="line">    glPushName(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  Set up view model</span></span><br><span class="line">    glPushMatrix();</span><br><span class="line">    &#123;</span><br><span class="line">        glMatrixMode(GL_PROJECTION);</span><br><span class="line">        glLoadIdentity();</span><br><span class="line">        gluPickMatrix(x, dy - y, PICK_TOL, PICK_TOL, viewport);</span><br><span class="line">        gluPerspective(<span class="number">60.0</span>, (GLfloat)windowW/(GLfloat)windowH, <span class="number">1.0</span>, <span class="number">30.0</span>);</span><br><span class="line">        glMatrixMode(GL_MODELVIEW);</span><br><span class="line">        glLoadIdentity();</span><br><span class="line">        <span class="comment">//          eye point   center of view      up</span></span><br><span class="line">        gluLookAt(camX, camY, camZ, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        </span><br><span class="line">        render(GL_SELECT);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    glPopMatrix();</span><br><span class="line">    </span><br><span class="line">    hits = glRenderMode(GL_RENDER);</span><br><span class="line">    </span><br><span class="line">    glMatrixMode(GL_PROJECTION);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    gluPerspective(<span class="number">60.0</span>, (GLfloat)windowW/(GLfloat)windowH, <span class="number">1.0</span>, <span class="number">30.0</span>);</span><br><span class="line">    glMatrixMode(GL_MODELVIEW);</span><br><span class="line">    glLoadIdentity();</span><br><span class="line">    <span class="comment">//          eye point   center of view      up</span></span><br><span class="line">    gluLookAt(camX, camY, camZ, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hits &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zVal = selectBuffer[<span class="number">1</span>];</span><br><span class="line">        tempHit = selectBuffer[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; hits; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectBuffer[<span class="number">4</span>*i+<span class="number">1</span>] &lt; zVal) &#123;</span><br><span class="line">                zVal = selectBuffer[<span class="number">4</span>*i+<span class="number">1</span>];</span><br><span class="line">                tempHit = selectBuffer[<span class="number">4</span>*i+<span class="number">3</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tempHit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouse</span><span class="params">(<span class="keyword">int</span> button, <span class="keyword">int</span> state, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">if</span> (state == GLUT_DOWN) &#123;</span><br><span class="line">        hit = doSelect((GLint) x, (GLint)y);</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    glutPostRedisplay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在鼠标点击事件中调用了 <code>doSelect</code> 方法：切换到选择模式后重画视图，接着切换回来，得到选中的名称并返回。在绘制函数中对选中对象设置不同的材质便得到了下面的效果。</p>
<p><img src="http://ww1.sinaimg.cn/large/72d7aee5jw1f03ulq5kbfj20pc0keq6a.jpg" alt="Select Demo"></p>
<p>通过改变绘制的分支语句，也可以实现多选或选择一行的功能。在命名时如果仔细小心，也可以实现分层选择的功能。</p>
<h4 id="u4E00_u4E2A_u53C2_u8003_u8D44_u6599_uFF1A"><a href="#u4E00_u4E2A_u53C2_u8003_u8D44_u6599_uFF1A" class="headerlink" title="一个参考资料："></a>一个参考资料：</h4><ul>
<li><a href="http://web.cse.ohio-state.edu/~hwshen/581/Site/Slides_files/picking.pdf" target="_blank" rel="external">OpenGL Picking</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>OpenGL 有多种方法可以实现鼠标拾取物体，其中的两种方法比较常用。第一种通常被认为是标准的选择方法，它跟踪被被选中像素或包括其周围的一小片区域的所有对象，接下来具体介绍这种方法。第二种是选取一个颜色集，用互不相同的颜色绘制可以被选中的对象，通过检查选中点的颜色缓存的颜色]]>
    </summary>
    
      <category term="OpenGL" scheme="http://mainasuk.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可视化超立方体]]></title>
    <link href="http://mainasuk.com/2016/01/13/HypercubeVisualize/"/>
    <id>http://mainasuk.com/2016/01/13/HypercubeVisualize/</id>
    <published>2016-01-13T08:36:00.000Z</published>
    <updated>2016-01-13T08:54:11.000Z</updated>
    <content type="html"><![CDATA[<p>读过《思考的乐趣》的朋友一定还记得最后一章中那个令人匪夷所思的四维超立方体（<a href="https://zh.wikipedia.org/wiki/超方形" target="_blank" rel="external">hypercube</a>），生活在三维世界中的我们居然也可以去想象更高维的空间，真是有趣。</p>
<h1 id="u5EFA_u6A21"><a href="#u5EFA_u6A21" class="headerlink" title="建模"></a>建模</h1><p>可视化的第一步就是建模，类似于三维立方体，用四维坐标（x, y, z, w）表示超立方体的顶点。按照每增加一个维度，顶点数翻倍的规律来看，超立方体的顶点是立方体的两倍，即 16 个顶点。一种典型的超立方体的所有顶点可由下表列出。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:center">Vertex</th>
<th style="text-align:center">X</th>
<th style="text-align:center">Y</th>
<th style="text-align:center">Z</th>
<th style="text-align:center">W    </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0    </td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1    </td>
</tr>
</tbody>
</table>
<p>可以看到前 8 个顶点的 w 坐标值为 0，也就是说用这八个点去取出超立方体的一个超平面（hyperplane），这个超平面就是一个立方体。类似的，它有 32 条边，24 个面。</p>
<p>对边进行考虑，可以发现 12 条边构成一个立方体，将表格前八个顶点构成的立方体的 w 值设为 1（或者说将它沿 w 轴平移），将得到的几何体的每个顶点与变换前的顶点相连，计算边数得 12＋12+8 ＝ 32 条边。</p>
<p>利用离散数学的知识，我们可以建立顶点集和边集，用以表示一个超立方体。在绘制时将遍历边集，绘制出所有边，完成可视化的工作。</p>
<h2 id="u6295_u5F71"><a href="#u6295_u5F71" class="headerlink" title="投影"></a>投影</h2><p>类似在纸面上绘制立方体，我们将超立方体投影（projection）到三维空间，从而达到可视化的目的。若沿着 w 轴进行平行投影，可直接得出一个立方体，它们的顶点是重叠的（<a href="http://hypersolid.milosz.ca" target="_blank" rel="external">请参考这里</a>）。</p>
<p>在可视化的同时为了便于观察和理解，我们将顶点的 w 值均匀(若可以动态旋转并投影，则是否为 1/3 就不重要了)的投影在其余坐标轴上。比如 P(x, y, z, w) 变换到 P(x-(1/3)w, y-(1/3)w, z-(1/3)w)。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/72d7aee5jw1ezxywm31shg20i20fhk42.gif" alt="将超立方体进行简单的投影"></p>
<p>这里的几何体仅仅进行了 xyz 轴的旋转，换句话说，只移动了摄像机。</p>
<h2 id="u65CB_u8F6C"><a href="#u65CB_u8F6C" class="headerlink" title="旋转"></a>旋转</h2><p>利用 OpenGL 的工具函数可以方便的沿着某个轴进行旋转，所以沿着 x、y、z 轴旋转几何体是很方便的，旋转的结果也是易于理解的。若将 w 轴考虑在内的话，就必须要手工进行模型变换了，以 XW 旋转为例，使用变换矩阵：</p>
<pre><code>[cos(t)    0    0    sin(t)
   0       1    0       0
   0       0    1       0
 -sin(t)   0    0    cos(t)]
</code></pre><p>将模型中的点通过与变换矩阵相乘，所得点即为旋转后的点。之后进行投影和绘制。</p>
<h2 id="u751F_u6210_u7ED3_u679C"><a href="#u751F_u6210_u7ED3_u679C" class="headerlink" title="生成结果"></a>生成结果</h2><p><img src="http://ww2.sinaimg.cn/mw690/72d7aee5jw1ezxywhcvmsg20fo0f9wmc.gif" alt="对超立方体进行 XW 旋转"></p>
<p>啊呀～和 Wiki 里的 <a href="https://zh.wikipedia.org/wiki/超方形#/media/File:8-cell.gif" target="_blank" rel="external">GIF</a> 图不太像，修改一下投影方法，完成～</p>
<p><img src="http://ww2.sinaimg.cn/mw690/72d7aee5jw1ezxywt0vcqg20hk0ebts2.gif" alt="旋转中的超立方体"></p>
<p>不过，就算投影看上去是一个立方体嵌套在另一个里面，实际上却根本不是那回事。（至于旋转 XW 实际上发生了什么，对照下面链接中的平行坐标系大概就能看懂了。）</p>
<p>这里有一个不错的演示工具，可以提供参考：<br><a href="http://exposedata.com/hypercube/rotate/" target="_blank" rel="external">http://exposedata.com/hypercube/rotate/</a></p>
<h3 id="u76F8_u5173_u8D44_u6599"><a href="#u76F8_u5173_u8D44_u6599" class="headerlink" title="相关资料"></a>相关资料</h3><ol>
<li><a href="https://andrewharvey4.wordpress.com/2008/10/21/an-introduction-to-hypercubes/" target="_blank" rel="external">An Introduction to Hypercubes</a></li>
<li><a href="http://www.interactiveds.com.au/images/4D.htm" target="_blank" rel="external">Four dimensions has three rotational states</a></li>
<li><a href="http://www.geom.uiuc.edu/docs/outreach/4-cube/cubed.txt.html" target="_blank" rel="external">Rotation of a tesseract</a></li>
<li><a href="http://www.well.com/~abs/SIGGRAPH96/4Dtess.html" target="_blank" rel="external">Visualizing 4D Hypercube Data By Mapping Onto a 3D Tesseract - SIGGRAPH</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.84.2254&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">A METHOD FOR OBTAINING THE TESSERACT BY UNRAVELING THE 4D HYPERCUBE</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>读过《思考的乐趣》的朋友一定还记得最后一章中那个令人匪夷所思的四维超立方体（<a href="https://zh.wikipedia.org/wiki/超方形">hypercube</a>），生活在三维世界中的我们居然也可以去想象更高维的空间，真是有趣。</p>
<h1 id="u5EFA_u6A21"><a href="#u5EFA_u6A21" class="headerlink" title="建模"></a>建模</h1><p>可视化的第一步就是建模，类似于三维立方体，用四维坐标（x, y, z, w）表示超立方体的顶点。按照每增加一个维度，顶点数翻倍的规律来看，超立方体的顶点是立方体的两倍，即 16 个顶点。一种典型的超立方体的所有顶点可由下表列出。</p>]]>
    
    </summary>
    
      <category term="Math" scheme="http://mainasuk.com/tags/Math/"/>
    
      <category term="OpenGL" scheme="http://mainasuk.com/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux 汇编初体验与计算的目的]]></title>
    <link href="http://mainasuk.com/2015/12/25/Linux-assemble-and-Compute/"/>
    <id>http://mainasuk.com/2015/12/25/Linux-assemble-and-Compute/</id>
    <published>2015-12-25T02:30:00.000Z</published>
    <updated>2015-12-27T15:35:18.000Z</updated>
    <content type="html"><![CDATA[<p>说起来真的让人难以置信，我校汇编教材是老师自己写自己印的，拿到手的时候不由得想起高中在学校自己的印刷室里帮老师装订复习资料的场景……</p>
<p>好吧，Windows 系统下 的 DEBUG 只能说是勉强够用。先在记事本里写好程序，之后一行行敲入 DEBUG 下，调试起来甚至会简单一些。更进一步，用 MASA 和 LINK 也可以直接将汇编源文件编译成可执行文件。不过这里我以 Linux 为基础，如果对汇编有兴趣，可以尝试着写几个有用的程序，比如说～嗯， <code>0A</code> 与 <code>0D 0A</code> 间自由转换的转换器？</p>
<p>&gt; 从字节层面看文本文件，Windows 操作系统以 0D 0A（16进制）作为换行标记（End of Line，EOL），而 Linux 则以 0A 作为 EOL。于是，Linux 下编写的文本文件在 Windows 的记事本中会丢失换行符。乱码？噢，不不不，那是因为 Linux 以 Unicode 保存汉字，而 Windows 记事本以 GBK 编码去解析造成的，对于中文世界，情况大多如此。</p>
<a id="more"></a>
<h1 id="u73AF_u5883_u90E8_u7F72"><a href="#u73AF_u5883_u90E8_u7F72" class="headerlink" title="环境部署"></a>环境部署</h1><p>编写 Linux 汇编程序，首先需要一个你有一个基于 Intel CPU 的 Linux 系统。如果可以满足这点，恭喜，您已经达到基本的硬件要求了。这里我使用 Ubuntu 14.04 LTS 64 位发行版，它运行在一台超便宜的洋垃圾笔记本上:D</p>
<h2 id="u5DE5_u5177_u94FE"><a href="#u5DE5_u5177_u94FE" class="headerlink" title="工具链"></a>工具链</h2><ul>
<li>NASM 汇编编译器</li>
<li>ld 连接器</li>
<li>Gdb 调试器</li>
</ul>
<p>为了更好的编辑与调试，我使用 Kate 文本编辑器，安装 KWrite 文本编辑器后在 Kate 中添加终端插件（为了使用一个编辑器的插件需要另一个编辑器……呃，若终端插件无法工作，请安装 Konsole）。</p>
<p><img src="http://ww3.sinaimg.cn/large/72d7aee5gw1ezbnbozglqj20zk0m8dlv.jpg" alt="Kate"><br>（我想了半天风筝和它的联系，结果一点没有 OAO）</p>
<p>最后使用 Insight 作为 Gdb 的前端，如果感觉安装麻烦，使用 Kdbg 似乎也不错，只是对于汇编的支持差一些。好极了，现在我们有一个 GUI 的调试窗口用了。</p>
<p><img src="http://ww2.sinaimg.cn/large/72d7aee5gw1ezbn45fan5j20zk0m8afu.jpg" alt="Kdbg"></p>
<p><img src="http://ww3.sinaimg.cn/large/72d7aee5gw1ezbol3vh4cj20zk0m84ci.jpg" alt="insight"></p>
<h2 id="u5F00_u59CB_u4E4B_u524D"><a href="#u5F00_u59CB_u4E4B_u524D" class="headerlink" title="开始之前"></a>开始之前</h2><p>在编写汇编代码之前稍稍暂停一下，汇编语言到底是什么？在高级语言中，我们可以直接定义变量和函数，但是汇编语言中，没有那种方便的东西，我们能操纵的东西只有数字，除了数字……还是数字。</p>
<p>不过实际上我们还是有类似变量的东西，寄存器。在过去 Intel 的 CPU 还是 8080 的时候，操作系统（CP/M-80）简单的安装在内存的顶部，内存底部的 256 字节用做程序段前缀（Program Segment Prifix，PSP），存储一些杂碎。程序从软盘中读入，加载到内存地址 0x0100 处，当程序运行时，操作系统直接对 0x0100 进行寻址。</p>
<p>CPU 从内存中寻址，得到机器指令，然后依照指令进行运算。<a href="https://en.wikipedia.org/wiki/Intel_8080#/media/File:Intel_8080_arch.svg" target="_blank" rel="external">8080 CPU</a> 有 7 个寄存器用来存放运算数，它们的大小只有 8 位（没错，也就是说它的 CPU 是 8 位的）。它有 16 根地址线，8 根数据线。与地址线连接的是一个 16 位的地址缓存（Address Buffer），意味着它的寻址大小是 64K（0 – 65536）。</p>
<p><img src="http://ww3.sinaimg.cn/large/72d7aee5gw1ezbonwimv1j20sg0lcdh4.jpg" alt="64K 内存"></p>
<p>对地址 0x0100 进行寻址时，CPU 将地址缓存设置为 <code>0000 0001 0000 0000</code>，也就是将对应的存储芯片通低电压或高电压，啊，令人头大的晶体管。16 根地址线将选择信号加在芯片的选择器上，数字电路会给指定地址的存储单元通电，拿出这 1 个 bit 的数据，当 8 个芯片串在一起时，我们便得到了 8 bit (1 字节) 的数据。这个过程仅需要不可思议的几纳秒。</p>
<p><img src="http://ww1.sinaimg.cn/large/72d7aee5gw1ezbonc1z5pj20sg0lcjsf.jpg" alt="RAM 芯片"></p>
<p>得到机器指令后，CPU 执行出厂时烧录好的指令集中的一条，而汇编语言就是直接或间接操纵（从内存拿出）数据，命令 CPU 执行计算的语言。实际上汇编语言编译后的程序代码（机器指令）也是一些 0 和 1。说白了，计算机就是在 0 和 1 之间跳舞，数据和可执行代码并没有本质的区别（想出利用缓冲区溢出漏洞攻击的人简直是天才）。</p>
<p>后来的 8086 有 20 根地址线，8 根数据线，可以在操纵 1MB 的内存（更准确的说，是 1MiB，但这里不再特意区分 MB 与 <a href="https://en.wikipedia.org/wiki/Mebibyte" target="_blank" rel="external">MiB</a>）。而今天，32 位 CPU 可以寻址 4GB 内存，64 位 CPU 的寻址大小为 2^64 = 16777216TB。当然，CPU 和内存的技术也在变化，目前内存（<a href="http://www.techbang.com/posts/18381-from-the-channel-to-address-computer-main-memory-structures-to-understand?page=1" target="_blank" rel="external">DIMM</a>）的存储单元堆叠在一起，存储单元的存储方式也不是按列存储。而多核 CPU 的出现以及多级缓存的应用使得在大脑中构建一个计算机运行的模型愈发困难，若实际去考量程序的执行效率，就不可避免的需要考虑到内存存取，缓存命中，内存一致性的诸多问题。考虑目前 CPU 的执行速度和内存存取的速度，在 CPU 不是瓶颈的场景中做到尽量少的存取内存，并且提高缓存命中率（顺序存储／压缩数据），可有效提高程序效率。</p>
<p>噢天啊～让生活简单一点吧，尽管访问内存的细节很复杂，但我们通常将它抽象成一个非常长的书架，一个物理地址对应着一个字节。不过一定要头脑清楚，除非你知道自己在做什么，否则不要试着在这个抽象层面上做任何‘优化’。</p>
<h2 id="u6C47_u7F16_u7F16_u7A0B_u6A21_u578B"><a href="#u6C47_u7F16_u7F16_u7A0B_u6A21_u578B" class="headerlink" title="汇编编程模型"></a>汇编编程模型</h2><p>好像差不多了，不过再等一下。是的，如果你为 8 位的 Intel 8080 CPU 编写汇编程序，对 64K 内存直接寻址是可行的（实模式平面模型，real mode flat model）；若为 32位机编写程序，你也可以直接对 4GB 内存进行寻址（保护模式平面模型，protected mode flat model）。</p>
<p>为 16 位 Intel 8086 编写程序呢？它和 8080 一样使用 16 位的地址缓存，但却有 20 条数据线，可对 1MB 内存进行寻址。如何用 16 位寄存器生成 20 位地址呢？答案是出乎意料的，CPU 使用两个 16 位寄存器来计算物理地址。将 1MB 的内存分成许多段（segment），段开始的地址就是段地址，它存储在段寄存器。任何能被 16 整除的地址都可以作为段地址，范围为 <code>0x0 – 0xFFFF</code>。将段地址乘 16 再加上另一个寄存器中存储的偏移地址，就得到了一个 20 位的物理地址，常常这样表示 0042:0042。（实模式段模型，real mode segmented model）</p>
<p>当我们使用十六进制来看时，段的含义会更清楚。<code>0x42</code> 乘 16 等同于 <code>0000 0000 0400 0010</code> 左移四位，得到 <code>0x420</code>（<code>0000 0000 0400 0010 0000</code>），再加上一个 16 位偏移地址 <code>0x42</code> 等于 <code>0x462</code>（<code>0000 0000 0100 0110 0010</code>）。细心的朋友已经发现了，尽管段地址加偏移地址可以实现对 1MB 内存的寻址，但实际上物理地址所对应的实际地址并不唯一，这是由于段地址之间间隔 16 个字节，将段地址平移之后也可能会有合法的偏移地址来代表某个物理地址。而这也告诉了我们段的本质，它只是一个特殊的地址及其后面的若干字节，段的大小至多为 65535 字节（64K），段地址为 <code>0xFFFF</code> 的段的大小只有 16 字节。</p>
<p>Intel 的 CPU 有一个良好的特性（恐怕也有人对此不是很赞同），即向后兼容。目前的 CPU 的架构都是在早期的架构上不断改进，即使架构有重大的变化，暴露给系统的那一部分始终是一样的。这也就是为什么你把之前 32 位的操作系统更换为 64 位而没有任何错误发生的原因（如果有错，你也不能怪它，因为它太旧了 XD）。哦，对了，当在 Windows 下运行 DOS 时，实际上就是进入了虚拟 86 模式，因此进入 DEBUG 后就像是回到了 8086 的时代一样，我们只有 64K 内存可以使用。</p>
<p>听说 DOS 时代有很多有趣的事情可以做，比如将数据直接写入内存中与显存存在映射关系的地方，操纵内存便可以制作出一些动画。现在的操作系统采用保护模式平面模型（Protected mode flat model），它将段地址保护起来，仅由操作系统控制，系统利用它可以实现虚拟内存，保护操作系统内核。目前很多 CPU 已经寄存器都扩大为 64 位，采用长模式，除了将过去 80x86 CPU 的寄存器加长到 64 位，还增加了几个新的寄存器，它们没有提供向后兼容的特性，即只能以 64 位进行读取。除此之外，目前的 CPU 还提供了 128 位的 SSE 寄存器，可加速数学/图形计算，比如多个四元数运算（SIMD，Single Instruction Multiple Data）。</p>
<h1 id="u7F16_u5199_u4EE3_u7801"><a href="#u7F16_u5199_u4EE3_u7801" class="headerlink" title="编写代码"></a>编写代码</h1><p>现在我们可以来编写汇编程序了，尽管在 Ubuntu 64 位系统下编写，但我们还是使用 32 位汇编编译器。所以我们手里有几个 32 位寄存器，还有一些 Linux 系统调用。</p>
<figure class="highlight c++"><figcaption><span>hello.asm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">;  Program: Hello World</span><br><span class="line">;  </span><br><span class="line">;  Usage:</span><br><span class="line">;  nasm -f elf -g -F dwarf hello.<span class="keyword">asm</span></span><br><span class="line">;  ld -m elf-i386 -o hello hello.o</span><br><span class="line"></span><br><span class="line">section .data</span><br><span class="line">    helloMsg: db <span class="string">"Hello, world!"</span>, <span class="number">10</span></span><br><span class="line">    helloLen: equ $-HelloMsg</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">global _start:</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">        nop </span><br><span class="line">        mov eax, <span class="number">4</span>            ; sys_write</span><br><span class="line">        mov ebx, <span class="number">1</span>            ; <span class="built_in">stdout</span></span><br><span class="line">        mov ecx, helloMsg     ; message to print</span><br><span class="line">        mov edx, helloLen     ; message length </span><br><span class="line">        <span class="keyword">int</span> <span class="number">80</span>H               ; system call</span><br><span class="line">        </span><br><span class="line">        mov eax, <span class="number">1</span>            ; <span class="built_in">exit</span></span><br><span class="line">        mov ebx, <span class="number">0</span>            ; <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">int</span> <span class="number">80</span>H               ; system call</span><br><span class="line">        nop</span><br></pre></td></tr></table></figure>
<p>首先来看数据段。helloMsg 为字符串，<code>db</code> 意为 define byte，引号用来标记字符串，数字 10 是换行符标记（还记得 <code>0xOA</code> 吗）。helloLen 为字符串长度，<code>equ</code> 指令指示编译时计算它的值，$ 令牌标识记录位置，在这里，它记录着 <code>0x0A</code> 后的位置，减去 helloMsg（字符串开始位置），得到的就是字符串长度。</p>
<p>之后我们使用 <code>MOV</code> 命令（mov <em>dest</em>, <em>source</em>）将源操作数存储在目的操作数中。在这里，我们将数字 4 放置在寄存器 EAX （32 位通用寄存器，除 EAX 外，还有 EBX，ECX，EDX）中；将数字 1 放在 EBX 中；将字符串的起始地值放置在 ECX 中；将字符串长度放置在 EDX 中。<a href="http://www.int80h.org" target="_blank" rel="external">INT 80H</a> 将执行一个软件中断，它首先将下一条代码的地址压入堆栈，接着跳转到<a href="https://zh.wikipedia.org/wiki/中斷向量" target="_blank" rel="external">中断向量表</a>，中断向量引导程序跳转到 Linux 系统调用服务（执行内核空间中的代码），约定 EAX 寄存器存储服务编号，4 代表 sys_write 系统调用，EBX 指定输出为 stdout（0 代表 stdin，2 代表 stderr），ECX 和 EDX 提供字符串的开始地址和长度。当系统调用完成后，经过一些我们都不知道的操作后，数据就被打印到 stdout 中（<a href="http://rosettacode.org/wiki/Check_output_device_is_a_terminal" target="_blank" rel="external">一般为 TTY，可重定向</a>），之后将下一条代码的地址从堆栈中弹出并跳转到这个地址（IRET 指令），接着执行下一条指令。</p>
<p>类似的，服务编号 1 代表退出系统调用，EBX 存储返回值 0。若不这样结束程序，系统会抛出一个段错误（Segment fault）。至于 <code>NOP</code>，它不做任何事情，加在代码首尾是为了方便调试。</p>
<p>对于 DOS 汇编，字符串输出服务编号为 09H，字符串以 $ 符号结束（0x24）。也就是说，汇编程序不能移植。特别的，由于内核不同，Linux 汇编程序不能运行在 BSD Unix 下。</p>
<h2 id="u7F16_u8BD1_u8C03_u8BD5"><a href="#u7F16_u8BD1_u8C03_u8BD5" class="headerlink" title="编译调试"></a>编译调试</h2><p><img src="http://ww4.sinaimg.cn/large/72d7aee5gw1ezbna2jrtij20zk0m8dvm.jpg" alt="insight"></p>
<p>使用 NASM 和 ld 完成源代码的编译链接，如果是 32 位机，ld 命令可省略 -m elf_i386。编译完成后，在终端运行程序，便会得到打印结果 “Hello, world!”。</p>
<p>我们使用 insight 进行调试，可以看到程序的结构，内存由低到高排列，首先是 .text 段；其次是 .data 段；接下来是 .bss 段，尽管它是一个段，但在程序加载入内存后才会被分配空间，用来存放未初始化变量。通过 insight 还可以看到编译得到的机器指令：MOV EAX 4 编译为 <code>0x00000004B8</code>，采用<a href="https://zh.wikipedia.org/wiki/字节序" target="_blank" rel="external">小端对齐</a>。这里我使用另一个字符串，可以看到它以 <code>0x0A</code>结尾，共 14 字节。</p>
<p><img src="http://ww1.sinaimg.cn/large/72d7aee5gw1ezbpfdofzkj20sg0lcmxx.jpg" alt=""></p>
<h2 id="u8BA1_u7B97"><a href="#u8BA1_u7B97" class="headerlink" title="计算"></a>计算</h2><p>对于计算有一个很有趣的论断，不知道计算机同不同意。</p>
<blockquote>
<p>计算的目的是洞察事物本质，而不是获得数字<br>— Richard Hamming</p>
</blockquote>
<p>嘛～尽管这样说，恐怕很多事物的本质还是不能用计算去得到。有时候我也会去想象一个没有计算机的世界，是不是会更好呢。美丽的大自然？</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>说起来真的让人难以置信，我校汇编教材是老师自己写自己印的，拿到手的时候不由得想起高中在学校自己的印刷室里帮老师装订复习资料的场景……</p>
<p>好吧，Windows 系统下 的 DEBUG 只能说是勉强够用。先在记事本里写好程序，之后一行行敲入 DEBUG 下，调试起来甚至会简单一些。更进一步，用 MASA 和 LINK 也可以直接将汇编源文件编译成可执行文件。不过这里我以 Linux 为基础，如果对汇编有兴趣，可以尝试着写几个有用的程序，比如说～嗯， <code>0A</code> 与 <code>0D 0A</code> 间自由转换的转换器？</p>
<p>&gt; 从字节层面看文本文件，Windows 操作系统以 0D 0A（16进制）作为换行标记（End of Line，EOL），而 Linux 则以 0A 作为 EOL。于是，Linux 下编写的文本文件在 Windows 的记事本中会丢失换行符。乱码？噢，不不不，那是因为 Linux 以 Unicode 保存汉字，而 Windows 记事本以 GBK 编码去解析造成的，对于中文世界，情况大多如此。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://mainasuk.com/tags/Linux/"/>
    
      <category term="汇编" scheme="http://mainasuk.com/tags/%E6%B1%87%E7%BC%96/"/>
    
      <category term="计算机" scheme="http://mainasuk.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
</feed>
